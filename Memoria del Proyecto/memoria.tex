%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plantilla de memoria en LaTeX para la ETSIT - Universidad Rey Juan Carlos
%%
%% Por Gregorio Robles <grex arroba gsyc.urjc.es>
%%     Grupo de Sistemas y Comunicaciones
%%     Escuela Técnica Superior de Ingenieros de Telecomunicación
%%     Universidad Rey Juan Carlos
%% (muchas ideas tomadas de Internet, colegas del GSyC, antiguos alumnos...
%%  etc. Muchas gracias a todos)
%%
%% La última versión de esta plantilla está siempre disponible en:
%%     https://github.com/gregoriorobles/plantilla-memoria
%%
%% Para obtener PDF, ejecuta en la shell:
%%   make
%% (las imágenes deben ir en PNG o JPG)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 12pt]{book}
%\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel} 
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{float}  %% H para posicionar figuras
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX
\usepackage[shortlabels]{enumitem}
\usepackage{xcolor}


\title{Memoria del Proyecto}
\author{Paula Rodrı́guez Martı́nez}

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\begin{document}

\renewcommand{\refname}{Bibliografía}  %% Renombrando
\renewcommand{\appendixname}{Apéndice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
\begin{center}
\includegraphics[scale=0.8]{img/URJ_logo_Color_POS.png}

\vspace{1.75cm}

\Large
GRADO EN INGENIERÍA EN TECNOLOGÍAS DE TELECOMUNICACIÓN

\vspace{0.4cm}

\large
Curso Académico 2020/2021

\vspace{0.8cm}

Trabajo Fin de Grado

\vspace{2.5cm}

\LARGE
DR. SNAP!

\vspace{4cm}

\large
Autor : Paula Rodríguez Martínez \\
Tutor : Dr. Gregorio Robles
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Para firmar
\clearpage
\pagenumbering{gobble}
\chapter*{}

\vspace{-4cm}
\begin{center}
\LARGE
\textbf{Trabajo Fin de Grado}

\vspace{1cm}
\large
Dr. Snap!

\vspace{1cm}
\large
\textbf{Autor :} Paula Rodríguez Martínez \\
\textbf{Tutor :} Dr. Gregorio Robles\\

\end{center}

\vspace{1cm}
La defensa del presente Proyecto Fin de Carrera se realizó el día \qquad$\;\,$ de julio \newline de 2021, siendo calificada por el siguiente tribunal:


\vspace{0.5cm}
\textbf{Presidente:}

\vspace{1.2cm}
\textbf{Secretario:}

\vspace{1.2cm}
\textbf{Vocal:}


\vspace{1.2cm}
y habiendo obtenido la siguiente calificación:

\vspace{1cm}
\textbf{Calificación:}


\vspace{1cm}
\begin{flushright}
Fuenlabrada, a \qquad$\;\,$ de julio de 2021
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dedicatoria

\chapter*{}
\pagenumbering{Roman} % para comenzar la numeracion de paginas en numeros romanos
\begin{flushright}
\textit{Dedicado a \\
mi familia / mi abuelo / mi abuela}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Agradecimientos

\chapter*{Agradecimientos}
%\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado 

Aquí vienen los agradecimientos\ldots Aunque está bien acordarse de la pareja, no hay que olvidarse de dar las gracias a tu madre, que aunque a veces no lo parezca disfrutará tanto de tus logros como tú\ldots 
Además, la pareja quizás no sea para siempre, pero tu madre sí.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen

\chapter*{Resumen}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado

En la actualidad, aprender programación aporta al ser humano habilidades como la resolución de problemas, la abstracción de ellos o la depuración de errores. En este mundo tecnológico se ha hecho imprescindible la docencia de asignaturas que introduzcan a los estudiantes en el mundo de los programadores. Snap! Berkeley es una plataforma que ofrece la posibilidad de crear programas de forma visual con bloques que realizan funciones o acciones sin necesidad de aprender un lenguaje de programación. De esta forma se puede introducir la programación y sus conceptos básicos desde edades tempranas haciendo que sea de una forma divertida, interactiva y didáctica.

Este trabajo de fin de grado aspira a ser una herramienta web que analiza los proyectos o programas de Snap! creados por los estudiantes basando el análisis en ocho conceptos del pensamiento computacional. Con ello se pretende que el alumno pueda ver sus puntos fuertes y sus carencias para mejorar y conseguir un nivel mayor de programación. Además, postula ser una ayuda para el profesorado en la corrección de de los proyectos de un aula entera.

La aplicación web se llamará Dr. Snap! y surge de la idea del famoso analizador Dr. Scratch que analiza los proyectos de la plataforma Scratch. Para este trabajo se utilizarán tecnologías como el entorno Django, el lenguaje Python, las plantillas de HTML o el servidor que ofrece \url{https://www.pythonanywhere.com/}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés

\chapter*{Summary}
%\addcontentsline{toc}{chapter}{Summary} % si queremos que aparezca en el índice
\markboth{SUMMARY}{SUMMARY} % encabezado

Here comes a translation of the ``Resumen'' into English. 
Please, double check it for correct grammar and spelling.
As it is the translation of the ``Resumen'', which is supposed to be written at the end, this as well should be filled out just before submitting.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Las buenas noticias es que los índices se generan automáticamente.
% Lo único que tienes que hacer es elegir cuáles quieren que se generen,
% y comentar/descomentar esa instrucción de LaTeX.

%%%% Índice de contenidos
\tableofcontents 
%%%% Índice de figuras
\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras
%%%% Índice de tablas
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
%\listoftables % indice de tablas


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCCIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción}
\label{sec:intro} % etiqueta para poder referenciar luego en el texto con~\ref{sec:intro}
\pagenumbering{arabic} % para empezar la numeración de página con números
Con el avance de las tecnologías, la programación y el pensamiento computacional se han extendido de tal forma que ya se incluyen en el temario de educación secundaria obligatoria. Un programa no es más que un conjunto de sentencias que dan instrucciones a un ordenador y es necesario aprender un lenguaje de programación con el que escribirlas.

Este trabajo de fin de grado gira entorno a una plataforma de programación interactiva denominada Snap! Berkeley. En ella los usuarios crean programas a partir de bloques ya definidos o creando tus propios bloques. Además, ofrece la opción de subir todos tus proyectos y cuenta con un foro, con tutoriales y con un manual de referencia. Se creará una aplicación web en la que los usuarios puedan subir el proyecto creado en Snap! para ser analizado y poder obtener resultados basados en su nivel de programación. 

La aplicación web se llamará Dr. Snap! y surge de la ya implementada herramienta web Dr. Scratch que analiza proyectos de la plataforma Scratch~\cite{moreno2015dr}. A raíz de Scratch se desarrolló Snap! Berkeley como extensión y mejora, por lo que Dr. Snap y Dr. Scratch giran ambos entorno a la misma idea y funcionalidad. Sin embargo, este proyecto pretende ser completamente independiente y con ideas nuevas y originales.

Con la intención de ser una herramienta con carácter académico, se desarrollará tanto para estudiantes como para profesores con el objetivo de que los estudiantes aprendan a programar de forma óptica, clara y concisa y a los profesores se les facilite el trabajo de corrección.

\section{Conceptos básicos de programación}

\subsection{Programación en bloques}
A raíz del desarrollo que se ha producido en la docencia de los fundamentos de programación y en las TIC, surge el concepto de ludificación. ``La ludificación es un método con la finalidad de crear una experiencia significativa y motivadora a través de la integración de mecánicas de juego en entornos y aplicaciones no lúdicas''~\cite{lopez2017pensamiento}.~Es decir, debe crear un entorno atractivo que promueva la diversión combinada con el aprendizaje y la actividad cognitiva buscando siempre la motivación interna de los participantes~\cite{vsimko2014ludificacion}. En nuestro contexto, el sistema de ludificación es la plataforma de lenguaje visual previamente mencionada Snap! Berkeley en la que los participantes programan a través de bloques funcionales.

La programación en bloques consiste en crear programas encajando unas piezas predefinidas que permiten hacer funciones o procedimientos sin necesidad de un lenguaje de programación. Tiene similitudes al pseudocódigo y al diagrama de control. Es un tipo de enseñanza activa que promueve el pensamiento computacional, las diferentes formas de analizar y abordar los problemas y el diseño constructivo visual.
En este ámbito, Scratch es una de las plataformas virtuales más conocidas y permite la implementación de juegos, animaciones e historias. En ella se pueden crear programas como se indica en la figura~\ref{figura:scratch} donde se observan diferentes bloques con funciones distintas.
\begin{figure}[h]
        \centering
        \includegraphics[scale=0.55]{img/scratch.png}
        \caption{Ejemplo de programa con bloques (en este caso es un programa de la plataforma Scratch).}
        \label{figura:scratch}
\end{figure}

\subsection{Pensamiento computacional}
El pensamiento computacional es ``el proceso de pensamiento que interviene en la formulación de los problemas y sus soluciones, de manera que las soluciones se representen de forma que pueda ser realizada por un procesador de información''~\cite{wing2011research}. Para poder evaluar sus competencias se han definido los siguientes puntos basados en la herramienta Dr. Scratch:
\begin{enumerate}[1)]
    \item Paralelismo: sucesión simultánea de varias instrucciones o acciones. Por ejemplo, se necesitaría paralelismo si quisiésemos que dos personajes giren 15º a la vez.
    \item Condicionales: cuando las instrucciones se pueden ejecutar o no en función del resultado de una condición. Los condicionales más típicos, entre ellos, se incluyen los operadores lógicos (and, or, not).
    \item Control de flujo: hace referencia al orden en el que se ejecutan las instrucciones. El orden natural en un programa sería que la instrucciones fuesen ejecutándose una a una. Sin embargo, también se debe incluir la opción de ejecutar un conjunto de instrucciones hasta que suceda otro evento o que las instrucciones se ejecuten las veces que queramos (hablamos de bucles).
    \item Abstracción: se consigue dividiendo un problema grande en pequeños conjuntos más sencillos y simples separando en \emph{scripts} o creando bloques definidos.
    \item Sincronización: supone el ajuste temporal de diferentes eventos. Es decir, cuando se desea ejecutar una instrucción una vez ha terminado otra se requiere que ambos eventos estén sincronizados.
    \item Interactividad con el usuario. Así, conseguimos hacer intervenir al usuario de alguna forma como puede ser introducir un nombre o pulsar una tecla.
    \item Datos: esto incluye las operaciones con las variables, listas y atributos.
    \item Diversidad: supone el uso de distintos tipos de bloques como de movimiento y de evento.
\end{enumerate}

\section{Snap! Berkeley}

Snap! es una plataforma virtual que se programó en JavaScript como extensión de la ya mencionada plataforma Scratch~\cite{harvey2013snap}. ~Snap! define un lenguaje de programación visual que permite programar por bloques. Como novedades implementa listas avanzadas y permite crear bloques definidos  más potentes. La página principal de Snap! se observa en la figura~\ref{figura:ppal_snap} y en ella podemos ver que nos ofrece la opción de correr el programa, de ver ejemplos y de obtener el manual de referencia. En Snap! Berkeley, además de crear programas, se pueden subir estos proyectos a la comunidad de Snap! para que todo el mundo pueda probarlos y ver cómo se han implementado.
\begin{figure}[h]
        \centering
        \includegraphics[scale=0.4]{img/snap_ppal.png}
        \caption{Página principal de Snap! Berkeley}
        \label{figura:ppal_snap}
\end{figure}


El manual de referencia consta de once capítulos y de dos anexos y en ellos se explica en detalle todo lo relacionado con el manejo de sus bloques para programar~\cite{harvey2017snap}. Por ejemplo, el capítulo I sección A trata sobre cómo crear paralelismo en Snap! gracias a la configuración de un tipo de bloques o el capítulo III te explica cómo crear tus propios bloques definidos.

El entorno de programación de Snap! donde se crean los programas se indica en la figura~\ref{figura:entorno_snapp}. En la sección indicada como A) se encuentran los bloques definidos de 8 categorías para crear los programas, la sección B) es donde se crean los conjuntos de instrucciones arrastrando los bloques y uniéndolos entre ellos. Por último, la sección C) es donde se puede ver dichas instrucciones ejecutándose y siendo aplicadas a los personajes que definimos.
\begin{figure}[h]
        \centering
        \includegraphics[scale=0.35]{img/entorno.png}
        \caption{Entorno para programar en Snap!}
        \label{figura:entorno_snapp}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBJETIVOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Objetivos} % título del capítulo (se muestra)
\label{chap:objetivos} % identificador del capítulo (no se muestra, es para poder referenciarlo)

\section{Objetivo general} % título de sección (se muestra)
\label{sec:objetivo-general} % identificador de sección (no se muestra, es para poder referenciarla)

Mi trabajo fin de grado consiste en crear una herramienta docente que analiza los proyectos creados en Snap! Berkeley, una implementación que permite programar de forma interactiva a partir de bloques. Para ello se ha creado una aplicación web a través del \emph{framework} Django y con el servidor PythonAnywhere\footnote{\url{https://www.pythonanywhere.com}}.

\section{Objetivos específicos}
\label{sec:objetivos-especificos}

Para este proyecto hemos definido dos modos de interactuar:
\begin{itemize}
\item 
El modo estudiante consiste en analizar un fichero XML obtenido a través de la URL del proyecto de Snap! El análisis está basado según una rúbrica que lo divide en 8 secciones, admitiendo una calificación del 0 al 3 cada una.
\begin{itemize}
      \item
     Paralelismo
      \item
     Condicionales
      \item
      Control de flujo
      \item
      Abstracción
      \item
      Sincronización
      \item
      Interactividad
      \item
      Representación de datos
      \item
      Uso de categorías o diversidad
    \end{itemize}
El nivel final, que es el que da la calificación total del proyecto obtenida a partir de la media de todas sus partes, resulta ser:
    \begin{itemize}
          \item
          Nulo $\rightarrow $ [0, 0.5)
          \item
          Básico $\rightarrow $ [0.5, 1.5)
          \item
          Intermedio $\rightarrow $ [1.5, 2.5)
          \item
          Avanzado $\rightarrow $ [2.5, 3]
     \end{itemize}
\item
El modo profesor amplía el modo estudiante con la posibilidad de analizar un archivo ZIP en el que se encuentran los XML de los proyectos de sus alumnos. Una vez analizados todos los archivos XML, se da la opción de descargar las puntuaciones  de las 8 secciones y el nivel final en formato CSV.

\end{itemize}
Por último, para ambos modos se han definido varios \emph{dashboards} en el que se muestran gráficos de los datos de los proyectos analizados.
\section{Planificación temporal}
\label{sec:planificacion-temporal}

Este trabajo de fin de grado ha requerido un tiempo estimado de 7 meses dedicándole de media 4 tardes/noches a la semana. Al tener que hacer las prácticas de la carrera, el trabajo de fin de grado de aeroespacial y continuar con mi trabajo de camarera en un restaurante se me hizo imposible ir más rápido. En la figura~\ref{figura:tiempo} se visualiza un diagrama del tiempo que dedique aproximadamente a los puntos más importantes del trabajo. 
 \begin{figure}[h]
		\centering
		\includegraphics[scale=0.45]{img/tiempo.PNG}
		\caption{Planificación temporal del trabajo de fin de grado.}
		\label{figura:tiempo}
	    \end{figure}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ESTADO DEL ARTE %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Estado del arte}
\label{chap:estado}

En este apartado se explicará de forma breve y concisa los lenguajes de programación, bases de datos, modelos, arquitecturas y demás tecnologías que se hayan necesitado para la implementación de nuestra aplicación web. Haremos una clara distinción entre los conceptos básicos que se han necesitado adquirir y las tecnologías usadas para que nuestra aplicación ofrezca las prestaciones prometidas y tenga un buen diseño web.

\section{Snap! Berkeley}
Como hemos mencionado previamente, la aplicación web será un analizador de proyectos creados desde Snap! Berkeley. Cabe destacar que el funcionamiento de Snap! como lenguaje resulta ser muy potente pudiendo crear programas complejos y elaborados. Para entender el funcionamiento de la programación en Snap! es necesario definir algunos conceptos básicos de la programación por bloques~\cite{harvey2017snap}:

\begin{itemize}

	\item Sprite: Hace referencia a los diferentes gráficos o personajes de nuestro 		programa. Por ejemplo, en la figura~\ref{figura:sprites} se puede observar que tenemos 	dos sprites (cuadrado y círculo) y a cada uno de ellos se les pueden asignar funciones de 	movimiento, sonidos, es decir, cada sprite tiene sus propios \emph{scripts}. Esto es muy útil 	sobretodo para crear animaciones, historias o juegos interactivos con personajes. Los sprites tienen una apariencia que puede cambiarse gracias a los ``customes'' que se pueden pintar como los dos del ejemplo anterior o se pueden importar.

	    \begin{figure}[h]
		\centering
		\includegraphics[scale=0.3]{img/sprite.png}
		\caption{Dos sprites en SNAP!}
		\label{figura:sprites}
	    \end{figure}
	\item Script: es una pila o agrupación de bloques que se inicializan con los llamados 	\textit{hat blocks} y realizan un conjunto de acciones como en la 		figura~\ref{figura:script}. 
    
     \begin{figure}[h]
        \centering
        \includegraphics[scale=1]{img/script.PNG}
        \caption{Script en Snap!}
        \label{figura:script}
    \end{figure}
	    
     \item Block: son los elementos básicos del lenguaje de Snap!. Se deben arrastrar a la zona de \textit{scripting} para encajarlos y crear scripts que hagan funciones. Existen diferentes clasificaciones:
     
     \begin{enumerate}[1)]
        \item Según las categorías:
   
            \begin{enumerate}[a)]
                \item Motion: bloques que permiten dar movimiento al sprite o personaje.
                \item Looks: permite cambiar las propiedades de apariencia del personaje.
                \item Sound: permite añadir sonidos, cambiar el volumen...
                \item Pen: permite pintar líneas o crear estampas del sprite.
                \\
                    \begin{figure}[h]
                        \centering
                        \includegraphics[scale=0.45]{img/4-blocks.png}
                        \caption{Bloques de tipo motion, look \&  sound y pen, respectivamente.}
                        \label{figura:bloque1}
                    \end{figure}
                \item Control: bloques para inicializar los scripts o para hacer bucles.
                \item Sensing: permite distinguir interacciones como cuando pulsas una tecla o cuando tocas un borde con el ratón.
                \item Operators: permite hacer operaciones como sumas, multiplicaciones,operaciones lógicas...
                \item Variables: incluye listas, operaciones con listas, inicialización de variables...
                \begin{figure}[h]
                        \centering
                        \includegraphics[scale=0.5]{img/blo4-2.png}
                        \caption{Bloques de tipo motion, look \& sound y pen, respectivamente.}
                        \label{figura:bloque2}
                \end{figure}
                 \end{enumerate}
        \item Según su funcionalidad:
            \begin{enumerate}[a)]
             \item Command block: se corresponden con bloques que tienen acciones ya definidas.
             \item Reporter block: proporciona un valor de entrada que será usada en una acción.
             \item Predicate: es otro tipo de ``reporter block'' ya que devuelve una entrada de tipo True o False. Tiene sentido usarlos en bucles o condicionales.
            \end{enumerate}
        \item Según su forma:
             \begin{enumerate}[a)]
             \item Hat block: son los que se usan para inicializar un script y solo se pueden poner al principio.
             \item Brick shape: de forma simple y de tipo command block.
             \item C shape: es de tipo command pero admite dentro de él otro script o un único brick shape. Se corresponde con los bucles y los condicionales.
             \item E shape: compuesto con dos bloques C shape.
             \item Oval shape: se corresponde con los reporter block. Por ejemplos, las variables son óvalos de color naranja.
             \item Hex shape: se corresponde con los predicate block.
             \end{enumerate}
        En la figura~\ref{figura:shape} tenemos varios ejemplos.
        
        \begin{figure}[h]
                        \centering
                        \includegraphics[scale=0.55]{img/shapes.PNG}
                        \caption{Bloques según la forma en Snap!}
                        \label{figura:shape}
        \end{figure}
    \end{enumerate}
    
\end{itemize}

\section{Modelo cliente-servidor} 
\label{sec:seccion1}
A día de hoy, la mayoría de las aplicaciones utilizan un esquema basado en el llamado modelo cliente-servidor. Es una arquitectura orientada a servicios donde los clientes son los usuarios de los servicios y de sus servidores asociados~\cite{castro2015arquitectura}.
 \begin{itemize}
          \item
         Cliente: es la parte encargada de mandar peticiones al servidor y recibir las respuestas de este. Los usuarios interaccionan con la parte del cliente.
          \item
          Servidor: es la parte encargada de ofrecer un servicio, es decir, de recibir peticiones por parte de los clientes y de proveerles las respuestas adecuadas a dichas peticiones.~\cite{lizama2016redes} 
     \end{itemize}
     
Las ventajas de este modelo:
\begin{itemize}
    \item Centralizado
    \item Mantenimiento simple
    \item Da servicios a más de un cliente 
    \item Interoperabilidad con el uso de protocolos estándar
\end{itemize}

Las desventajas de este modelo:
\begin{itemize}
    \item Problemas de congestión directamente proporcional al número de clientes
    \item Mantenimiento simple
    \item Escalable~\cite{lizama2016redes} 
\end{itemize}

\begin{figure}[h]
        \centering
        \includegraphics[scale=0.4]{img/Cliente-Servidor.png}
        \caption{Modelo cliente servidor}
        \label{figura:cliente-servidor}
    \end{figure}

Cabe mencionar que es un modelo de aplicación distribuida ya que las tareas que se realizan (solicitar recursos o enviarlos) se reparten entre cliente y servidor. Por tanto, distinguimos 3 partes fundamentales de una aplicación distribuida:
\begin{itemize}
    \item Capa de presentación: también llamada interfaz de usuario, es responsable del control de la interacción entre el usuario y la aplicación. Se engloban todas las tareas que deben ser realizadas por la parte cliente del modelo general~\cite{marini2012modelo}. Por ejemplo, para el aspecto de la aplicación web se puede usar CSS, un lenguaje de estilos. Además,esta capa se corresponde en la actualidad con el concepto de \textit{frontend} de una aplicación web.
    \item Capa de negocio: es la capa intermedia ya que se comunica con la capa de presentación y con la capa de datos~\cite{bazurto2018arquitectura}. Asegura las directrices o reglas del negocio, controla las secuencias de acciones y aísla los cambios de las interfaces de los usuarios y de los datos~\cite{marini2012modelo}.
    \item Capa de datos: es la que tiene los datos y la que se encarga de acceder a ellos y operar con ellos. Esta capa se corresponde con el concepto de \textit{backend}. Las tecnologías que se incluyen en esta capa son tales como los gestores de bases de datos o los frameworks.
\end{itemize}
\begin{figure}[h]
        \centering
        \includegraphics[scale=0.4]{img/3capas.png}
        \caption{Modelo de 3 capas}
        \label{figura:3capas}
\end{figure}
\section{Arquitectura MVC y Django}
La arquitectura MVC divide las partes de una aplicación en modelo, vista y controlador de forma que se pueda implementar cada parte por separado. Al ser entidades independientes, el cambio de una de ellas no supondrá la necesidad de cambiar ninguna de las otras~\cite{gonzalez2012patron}. Django es el framework que usamos para esta aplicación y se basa en este patrón MVC:

\begin{itemize}
    \item Modelo: se encarga de la representación de los datos. En Django se corresponde con el módulo models.py.
    \item Vista: se corresponde a la lógica de aplicación y se encarga de la presentación al usuario de los datos del modelo. En Django, las vistas se corresponden al módulo views.py y delegan la presentación de información en las plantillas o templates. Por eso, se puede decir que su arquitectura es MTV (modelo-template-vista) en vez de MVC como podemos observar en la figura~\ref{figura:MVC}.
    \item Controlador: recibe los eventos de entrada y contiene reglas de gestión de eventos como indicar cambios al modelo o elegir la vista adecuada para mostrar resultados. 
\end{itemize}

\begin{figure}[h]
        \centering
        \includegraphics[scale=0.42]{img/django_request.png}
        \caption{Arquitectura MVC en Django}
        \label{figura:MVC}
\end{figure}
\section{Representational state transfer}
REST es un modelo de diseño de servicio web que define un conjunto de principios de una arquitectura basada en recursos apto únicamente para aplicaciones distribuidas. Supone una mejora en la facilitación en el intercambio de datos entre el cliente y el servidor que, por ejemplo, el protocolo simple de acceso a objetos (SOAP). Sus principios son:

\begin{enumerate}[a)] % (a), (b), (c), ...
\item Modelo cliente (capa de presentación) - servidor (capa de negocio y datos) sin estado. No es necesario recordar ningún dato ya que las peticiones HTTP que se generan llevan incluidas todas las cabeceras y datos necesarios para dar una respuesta sin depender del estado anterior.
\item Estructura URI para los recursos.
\item Transferencia de hipermedios como XML o JSON para la representación de datos o de estado de los recursos.
\item Uso de métodos HTTP y principio CRUD (create, read, update and delete). Por tanto, las operaciones que afectan a un recurso pueden ser:
\begin{itemize}
    \item GET: petición para obtener un recurso.
    \item POST: petición para crear un recurso en el servidor.
    \item PUT: petición para actualizar un recurso en el servidor.
    \item DELETE: petición para eliminar un recurso~\cite{rodriguez2008restful}.
\end{itemize}
\end{enumerate}
\section{FRONTEND}
Para la interfaz de usuario o la capa de presentación hemos utilizado en nuestro diseño web diferentes tecnologías como son HTML, CSS y JavaScript.
\begin{figure}[h]
        \centering
        \includegraphics[scale=0.45]{img/frontend.png}
        \caption{Elementos FRONTEND}
        \label{figura:frontend}
\end{figure}

\subsection{HTML}
HyperText Markup Language, en español lenguaje marcado de hipervínculos, es el lenguaje básico de construcción de páginas web. Se basa en texto que contiene referencias a enlaces, imágenes, tablas, textos u otros elementos. Un elemento HTML debe ir entre etiquetas que definen la orden o instrucción de lo que se quiere insertar~\cite{equipo2009diseno}. Por ejemplo, para insertar un título se podría usar la etiqueta \textit{h1} o para insertar una imagen \textit{img}. HTML se encarga de crear el contenido de la página web pero no del estilo o apariencia de dicha página, para ello es necesario el CSS. Es decir, si nosotros queremos insertar un formulario para rellenar datos en nuestra página web va a ser necesario definir en HTML los elementos del formulario como son sus atributos (action y method), los campos que queremos que el usuario rellene con sus datos y un botón para darle a enviar. Ahora, para que el formulario tenga una apariencia en concreto tendremos que usar CSS para dar estilo a los elementos HTML del formulario.

\begin{figure}[h]
        \centering
        \includegraphics[scale=0.6]{img/tags.PNG}
        \caption{Etiquetas en HTML}
        \label{figura:tags}
\end{figure}

\subsection{CSS}
Cascading Style Sheets, en español hojas de estilo en cascada, es el lenguaje de estilos que permite modificar la apariencia de páginas webs construidas en HTML. La sintaxis de una instrucción CSS es una declaración que tiene una propiedad y un valor~\cite{mdn}. La propiedad es la característica de estilo que se quiere cambiar, por ejemplo si queremos cambiar el fondo la propiedad sería ``background'', y el valor sería el color o imagen del fondo que se querría cambiar. Se agrupan las declaraciones referidas a un elemento concreto de HTML, denominado selector, en un bloque. En la figura~\ref{figura:css} se muestra un ejemplo de CSS dando estilo a un código HTML.

\begin{figure}[h]
        \centering
        \includegraphics[scale=0.4]{img/cssyhtml.PNG}
        \caption{CSS asociado al HTML}
        \label{figura:css}
\end{figure}

\subsection{JavaScript}
Lenguaje de programación interpretado y orientado a objetos usado para crear contenido dinámico en las páginas webs. Para insertar código JavaScript en HTML se debe indicar con la etiqueta script. Ofrece la oportunidad de convertir una página web que en un principio era estática, en una página interactiva donde se pueda incluir menús emergentes, botones para hacer click o incluso animaciones~\cite{mdn1}. Esto es posible gracias al modelo de programación basada en eventos utilizado por JavaScript en el que el script espera a que el usuario interactúe de alguna forma (evento), procesa la información y responde con una acción a través de una función. Por ejemplo, cuando el usuario pincha la pantalla el evento se denomina onClick. Cada evento tiene asociada una función que ejecuta JavaScript denominada ``event handler''~\cite{perez2019introduccion}.

\section{BACKEND}
Se corresponde con la parte del servidor, la base de datos y la aplicación. Para ello utilizamos un lenguaje de programación (en nuestro caso Python), un framework para desarrollar el sitio web (Django), una base de datos (sqlite3) y un proveedor de servidor online donde lanzar la aplicación (pythonanywhere). En la figura~\ref{figura:backend} vemos distintas tecnologías que forman parte del \textit{backend}.
\begin{figure}[h]
        \centering
        \includegraphics[scale=0.6]{img/backend.png}
        \caption{BACKEND}
        \label{figura:backend}
\end{figure}
\subsection{Python}
Lenguaje de programación creado por Guido van Rossum en los 90, administrado por Python Software Foundation y con licencia de código abierto. En nuestra aplicación web usaremos la versión 3.8.5. Las características principales de este lenguaje son las siguientes~\cite{gonzalez2014python}:
\begin{itemize}
    \item Lenguaje de alto nivel e interpretado
    \item Tipado dinámico 
    \item Fuertemente tipado
    \item Multiplataforma
    \item Programación orientada a objetos aunque permite también la programación imperativa, funcional y programación orientada a aspectos.
\end{itemize}
\subsection{Django}
Es un framework de alto nivel que permite crear una aplicación web usando Python de forma sencilla cuyas características más destacadas son~\cite{bennett2009practical}:
\begin{itemize}
    \item Tiene un mapeador objeto relacional (ORM) que es una biblioteca que reconoce y relaciona cómo es la base de datos o el código que tú escribas.
    \item Conjunto de bibliotecas HTTP que gestionan las peticiones y respuestas.
    \item Biblioteca de ruta de URLs para localizar el código que corresponde a la URL introducida. 
    \item Sistema de plantillas que conforman la interfaz del usuario.
    \item Basado en el patrón MVC con la variación de que las vistas delegan la presentación al sistema de plantillas.
    \item Por defecto la base de datos es sqlite3 pero se puede usar otras como MySQL, PostgreSQL u Oracle configurándolo en el módulo settings.py.
   
\end{itemize}

\begin{figure}[h]
        \centering
        \includegraphics[scale=0.43]{img/django.png}
        \caption{Aplicación en Django }
        \label{figura:appDjango}
\end{figure}
\subsection{SQLite3}
SQLite es un motor de datos SQL mundialmente utilizado, este motor está desarrollado en una biblioteca programada en C la cual tiene compatibilidad con la mayoría de lenguajes de programación utilizados a día de hoy, SQLite es un motor SQL confiable dado que la mayoría del código fuente presente en su biblioteca está destinado a la realización de test unitarios y procesos de validación, cabe destacar en SQLite las siguientes características~\cite{sqlite}: 
\begin{itemize}
    \item Autónomo y casi independiente: En el proceso de ejecución no existe un uso de más recursos que los proporcionados en el código fuente de SQLite, no realizando así un uso de bibliotecas u programas externos del sistema.
\item Carencia de servidor: Para este motor el sistema cliente-servidor clásico es cosa del pasado, pudiendo permitir que el proceso que requiera de SQLite lea y escriba directamente desde los archivos de la base de datos en disco. 
\item Configuración Cero: A diferencia de aplicaciones u otras tipologías de bases de datos, SQLite opta por la configuración cero, en la cual no es necesario configurar nada ni definir ningún parámetro para indicar a nuestro sistema que SQLite está presente. En la biblioteca no podremos encontrar ficheros de configuración.
\item Base de Datos transaccional: Esta dinámica aporta seguridad y estabilidad al proceso de la base de datos, en caso de una avería del sistema o de un corte de energía durante la transacción con un registro de la base de datos, SQLite detiene o confirma la transacción de forma automática, evitando de esta forma transacciones incompletas o fallos en el proceso.

\end{itemize}
\subsection{PythonAnywhere}
Proporciona un servidor para poder subir tu aplicación web a la nube. Es compatible con proyectos de Django y existen dos modalidades: de pago y gratuita. La de pago tiene más ventajas y opciones como es la posibilidad de elegir el dominio, al contrario que, la versión gratuita que te impone el dominio \url{http://yourusername.pythonanywhere.com/}. En nuestro caso, la aplicación estará alojada en \url{http://prodriguezmartinez.pythonanywhere.com/}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DISEÑO E IMPLEMENTACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Diseño e implementación}
En este capítulo detallaremos cómo hemos trabajado con las tecnologías explicadas en el capítulo 3 para poder crear la aplicación Dr. Snap!
\section{Arquitectura general} 
La arquitectura de la aplicación creada la podemos dividir como se muestra en la figura~\ref{figura:esquema}.
\begin{figure}[h]
            \centering
            \includegraphics[scale=0.5]{img/arquitectura.PNG}
            \caption{Esquema global de la aplicación.}
            \label{figura:esquema}
        \end{figure}

\label{sec:arquitectura}
\subsection{FRONTEND}
En este apartado se desarrolla la capa de presentación o interfaz del usuario. Para el aspecto de la aplicación web hemos añadido un estilo CSS asociado a unas plantillas HTML (templates) y hemos diseñado un logo con el programa Clip Studio Paint.
\begin{enumerate}[a)]
    \item \textbf{HTML Y TEMPLATES}:
    
    Las plantillas definen los elementos HTML de la página web en conjunto con el CSS que se encarga de dar el estilo y apariencia de los elementos de las plantillas. En este proyecto se ha usado una plantilla de referencia gratuita que se puede encontrar en el enlace siguiente. Se han hecho los cambios pertinentes para quedar de la forma que aparece en la figura~\ref{figura:index} donde se define la cabecera, el menú horizontal, el logo y el pie de página.\\
    
     \begin{figure}[h]
            \centering
            \includegraphics[scale=0.32]{img/index.png}
            \caption{Página índice de Dr. Snap!}
            \label{figura:index}
        \end{figure}
    
    A raíz de esta template ``índice'' se han extendido las demás gracias a las funcionalidades de Django``built-in template'' y ``template inheritance'' que permiten dejar bloques sin definir los cuales las plantillas ``hijo''  que se creen serán las encargadas de rellenarlos. Estas heredan los elementos de la de referencia como es la cabecera o el menú principal. De esta forma, se evita repetir código. En la figura~\ref{figura:herencia} se muestra el funcionamiento de la herencia de plantillas de Django en Dr. Snap! donde index.html es la plantilla de referencia y *.html, las plantillas hijo que dan contenido al bloque cuerpo heredando todos los demás elementos de index.html.
    
        \begin{figure}[h]
            \centering
            \includegraphics[scale=0.33]{img/herencia.png}
            \caption{Templates inherit en Django}
            \label{figura:herencia}
        \end{figure}
        
    Así resulta un directorio de plantillas para nuestra aplicación web como en la figura~\ref{figura:template} donde cada una de ellas se cargará con el contenido adecuado según las peticiones que reciba el servidor de Django o las respuestas que proporcione. Esto se consigue gracias a la función de renderizado que nos provee el framework Django y que se explicará más adelante en la parte de \textit{backend}.\\
      \begin{figure}[h]
            \centering
            \includegraphics[scale=0.245]{img/plantillas.png}
            \caption{Directorio de templates de Dr. Snap!}
            \label{figura:template}
        \end{figure}
    \item \textbf{CSS}:
    
    Como ya explicamos, el CSS es un lenguaje de estilo que proporciona las propiedades de apariencia de los elementos definidos en las plantillas HTML. Por ejemplo, en la figura~\ref{figura:cssyhtml} observamos como se vería la página sin CSS y con CSS. 
    \\
    \begin{figure}[h]
            \centering
            \includegraphics[scale=0.75]{img/css_2.PNG}
            \caption{ Página web sin CSS y con CSS}
            \label{figura:cssyhtml}
        \end{figure}
    
    Así, para dar estilo al botón de analyze del formulario lo definiríamos en CSS como aparece en la figura~\ref{figura:boton}, donde se hace referencia al elemento button (etiqueta en HTML) y se escriben las propiedades que queremos que tenga como es el color, el tamaño o la letra.\\
    
      \begin{figure}[h]
            \centering
            \includegraphics[scale=1.5]{img/css_boton.PNG}
            \caption{Código CSS de un botón}
            \label{figura:boton}
        \end{figure}
    
    
    \item \textbf{CLIP STUDIO PAINT PRO}:
    
    Programa de ilustración digital que se ha utilizado para diseñar el logo y algunas imágenes. Para este programa se ha requerido el conocimiento básico de diseño de viñetas, aplicación de tonos y texturas y del manejo de diferentes capas. Para el logo me he basado en el muñeco original de Snap! y le he añadido unas gafas, cejas, una corbata, un reloj y una lupa para darle un toque de profesor. En la figura~\ref{figura:logos} se puede ver la comparación de ambos. 
    \\
        \begin{figure}[h]
            \centering
            \includegraphics[scale=0.3]{img/logos.png}
            \caption{Muñeco de Snap! y de Dr. Snap!}
            \label{figura:logos}
        \end{figure}
        
    Además del logo y el muñeco, se ha cambiado la imagen principal de Snap! Berkeley añadiendo el lema de \textit{analyze your own project} en vez de \textit{build your own project} y cambiando al muñeco de Dr. Snap!. Se hizo gracias al sistema de capas que permite borrar zonas y añadir nuevas y se puede ver en la imagen~\ref{figura:snap}.
    
    \begin{figure}[h]
            \centering
            \includegraphics[scale=0.35]{img/snap.PNG}
            \caption{Imagen principal aplicación web Dr. Snap!}
            \label{figura:snap}
        \end{figure}
        
     Por último, para expresar los niveles de cada proyecto se me ocurrió poner al muñeco con un bocadillo de texto diciendo el nivel del proyecto. Los 4 niveles se observan en la figura~\ref{figura:levels}.
     
    \begin{figure}[h]
            \centering
            \includegraphics[scale=0.9]{img/levels.PNG}
            \caption{Imagen que dice el nivel de un proyecto.}
            \label{figura:levels}
        \end{figure}
    
    
    \item \textbf{JAVASCRIPT}:
    
       Se ha usado JavaScript para implementar un conjunto de dashboards. Un dashboard es un gráfico que muestra datos en forma de gráficos (diagrama de barras, de línea o donuts, por ejemplo) y con ello ver un resumen de los datos para poder estudiarlos y analizar posibles tendencias . En esta aplicación se han desarrollado tres de ellos gracias a JavaScript y a su biblioteca de código abierto Chart.js que admite ocho tipos de gráficos (de línea, de barra, de donut, circular, burbuja, radar, polar y de dispersión) y es responsive, adapta su diseño para la mejor visualización posible según el dispositivo desde el que se vea. De los tipos que proporciona hemos seleccionado el gráfico de barras y el gráfico de donut. Esta biblioteca, además de implementar dichos gráficos, permite la configuración y la interacción con ellos. Por ejemplo, se puede cambiar los colores de los gráficos, poner nombres a cada eje, añadir animaciones o gestionar todo tipo de eventos. En la figura~\ref{figura:js} se observa un gráfico circular y un gráfico de líneas. 
    \begin{figure}[h]
            \centering
            \includegraphics[scale=0.5]{img/chart.PNG}
            \caption{Gráfico circular y de líneas respectivamente de Chart.js}
            \label{figura:js}
        \end{figure}
    
       
\end{enumerate}

\subsection{BACKEND}
\begin{enumerate} [a)]
    \item \textbf{DJANGO:}
    
    Hemos descargado Django versión 3.1.1 y Python 3.8.5 para el desarrollo de la aplicación web. Como hemos mencionado Django será el entorno que nos permitirá crear la aplicación web de una forma muy sencilla. 
    
    Cuando nos creamos una aplicación en Django, lo primero que tenemos que hacer es configurar los diferentes módulos que hay. En la figura~\ref{figura:carpetas} podemos ver una representación de las carpetas y módulos más importantes que hay en un proyecto de Django: la carpeta llamada ``myproject'' contiene todos los módulos y archivos que gestionan el proyecto, la carpeta de nombre ``myfirstapp'' contiene todos los módulos y archivos que gestionan la aplicación web, el archivo ``db.sqlite3'' es la base de datos, la carpeta ``media'' es la que contiene todos los ficheros zip que los profesores suben, la carpeta ``template'' es en la que se guardan todas las plantillas HTML y el archivo ``manage.py'' es el manejador que se ejecuta, por ejemplo, para lanzar la aplicación o para crear nuevas migraciones.
     \begin{figure}[h]
            \centering
            \includegraphics[scale=0.6]{img/carpetas.PNG}
            \caption{Principal directorio del proyecto en Django.}
            \label{figura:carpetas}
        \end{figure}
        
    Veamos los módulos más importantes con mayor profundidad:
    \begin{itemize}
        \item settings.py: se debe configurar el nombre de la aplicación que has creado, los servidores que están permitidos, como es en nuestro caso \textit{pythonanywhere} o \textit{mylocalhost}; todos los paths o rutas donde encontrar los archivos estáticos, las plantillas u otros; la base de datos que queremos utilizar (por defecto, utiliza sqlite3) e incluso hay que configurar datos como la zona horaria o el idioma.
        \item urls.py: en este módulo definimos las posibles urls que vamos a encontrar en nuestra aplicación web y especificamos la vista asociada a dicho path url. En la tabla~\ref{Tabla:paths} podemos ver un resumen de las distintas urls que hemos definido con su vista asociada y la funcionalidad que tienen.
        
        \begin{table}[]
        \centering
            \begin{tabular}{|l|l|l|}
            \hline
            PATH URL & VISTA & FUNCIÓN \\ \hline
            / & principal & Proporciona la página principal de la aplicación \\ \hline
            /contact & info & Página que da información sobre la aplicación \\ \hline
            /analyze & analyze & \begin{tabular}[c]{@{}l@{}}Página que permite analizar los proyectos o \\ ficheros comprimidos en un zip según el modo en el que estés.\end{tabular} \\ \hline
            /basic & basic & Informa sobre los criterios para nivel básico. \\ \hline
            /intermediate & intermediate & Informa sobre los criterios para nivel intermedio. \\ \hline
            /advanced & advanced & Informa sobre los criterios para nivel avanzado. \\ \hline
            /login & login\_user & Permite iniciar sesión. \\ \hline
            /type-signup & choose & \begin{tabular}[c]{@{}l@{}}Permite registarse eligiendo si eres estudiante o \\ profesor.\end{tabular} \\ \hline
            /signup & signup & Permite registrarse. \\ \hline
            /logout & logout\_user & Permite cerrar sesión. \\ \hline
            /projects & show\_projects & \begin{tabular}[c]{@{}l@{}}Permite ver los proyectos analizados o introducir \\ un zip para descargarse el proyecto en csv.\end{tabular} \\ \hline
            /project/\textless{}name\textgreater{} & show\_project & \begin{tabular}[c]{@{}l@{}}Permite ver las puntuaciones de un proyecto y\\ su nivel.\end{tabular} \\ \hline
            /dashboard & dashboard & \begin{tabular}[c]{@{}l@{}}Enseña los gráficos con los proyectos por nivel\\ y da la opción de ver los de un zip o la \\ comparación de dos zips.\end{tabular} \\ \hline
            /dashboard/\textless{}tag\textgreater{} & dashboard\_level & \begin{tabular}[c]{@{}l@{}}Permite ver los proyectos al hacer un\\ click en uno de los niveles de los dashboard.\end{tabular} \\ \hline
            /admin/ & admin.site.urls & Gestiona los usuarios y contraseñas, entre otras. \\ \hline
            \end{tabular}
            \caption{Paths admitidos con sus vistas asociadas de Django.}
            \label{Tabla:paths}
        \end{table}
        
        
        
        \item views.py: son las funciones que reciben una petición HTTP, deben devolver una respuesta HTTP y están asociadas a un path de url como hemos explicado anteriormente. El ORM de Django recibe un path con una petición, mapea en el listado de urls a qué vista corresponde y se ejecuta dicha función para devolver la respuesta correcta renderizada con una de las plantillas HTML. Es decir, por ejemplo, si hacemos desde el navegador una petición GET para el recurso /analyze, la función vista analyze nos devolverá la respuesta HTTP definida en la función renderizada con la plantilla que hicimos para dicho recurso. La figura~\ref{figura:MVC} resume lo explicado. También se pueden hacer redirecciones a otras páginas, en caso de error mostrar página 404 o, incluso, pasar datos a las plantillas.
        \item models.py: se definen las clases  y sus respectivos campos para la base de datos. En nuestra aplicación web tendremos tres clases: usuario, proyectos y el tipo de usuario (profesor o estudiante). En la figura~\ref{figura:models} quedan reflejadas las tres clases y sus campos correspondientes. Cabe destacar que la clase user ya viene implementada por el sistema de autenticación de usuarios de Django (en ``django.contrib.auth''), el cual proporciona funciones como login, logout o signup o la clase \textit{models.user}.
           \begin{figure}[h]
            \centering
            \includegraphics[scale=0.45]{img/models.PNG}
            \caption{Clases y campos definidos en models.py}
            \label{figura:models}
        \end{figure}
    \end{itemize}
    
    \item \textbf{SQLITE3:}
    
    Como hemos dicho previamente, nuestra base de datos será la que viene por defecto en Django, es decir, sqlite3. Es una base de datos sencilla y para crearla lo primero que debemos hacer es indicarla en settings.py. Una vez definidas las clases en models.py se debe hacer una migración con los cambios hechos para luego migrarla. Cada vez que se cree una clase, se añada un campo nuevo o se elimine se debe hacer una migración que refleje estos cambios y luego migrarla a la base de datos. En la figura~\ref{figura:bbdd} se observan todas las tablas que hay creadas, sin embargo, las únicas que hemos creado nosotros, gracias al módulo de models.py, son las que empiezan por el nombre de la aplicación, es decir, \textit{myfirstapp\_proyectos} y \textit{myfirstapp\_tipo}. Todas las demás son implementadas por Django para diferentes funcionalidades, por ejemplo, \textit{auth user} es la tabla que representa la ya comentada clase user que viene ya predefinida con los campos de contraseña, Gmail, primer apellido...\\
    
       \begin{figure}[h]
            \centering
            \includegraphics[scale=0.55]{img/bbdd.png}
            \caption{Tablas de la base de datos de la aplicación}
            \label{figura:bbdd}
        \end{figure}
    
    \item \textbf{PYTHONANYWHERE:}
    
Para lanzar la aplicación de Django en pythonanywhere lo primero que debes hacer es crearte una cuenta de forma gratuita y clonar tu proyecto que debe estar previamente subido a GitHub. El siguiente paso es crearte un entorno virtual y descargar Django. Hay que configurar los paths del directorio donde está el código, las templates y los recursos estáticos. Una vez hecho todo esto ya tenemos disponible nuestra aplicación web durante 3 meses, en nuestro caso, en \url{http://prodriguezmartin.pythonanywhere.com}.

Una vez que lancé la aplicación web al probarla tenía un error que impedía usarla: no dejaba hacer peticiones ni redirecciones a otros sitios webs a no ser que estos estuvieran en la \textit{whitelist} de pythonanywhere o que mi cuenta fuese de pago. Para solucionar el problema, me puse en contacto con los técnicos y conseguí, tras mucha insistencia, añadir el dominio de \url{https://cloud.snap.berkeley.edu/} a la \textit{whitelist} ya que me denegaron el dominio de https://snap.berkeley.edu/ lo que supuso algunos cambios mínimos en el código de la aplicación web.

\end{enumerate}

\section{Funcionalidades de Dr. Snap!}
En este apartado vamos a explicar todas las funciones que he implementado para que la aplicación web cumpla su cometido como herramienta docente. Estas siguen un orden cronológico ya que algunas han surgido con el objetivo de mejorar o complementar otras.
\subsection{Analizar proyectos}
Para analizar un proyecto se necesita la URL del proyecto de Snap! y así conseguir el XML donde viene guardada la información de bloques, scripts y sprites del proyecto. La URL se consigue a través de un formulario como el de la figura~\ref{figura:xml}. Una vez que tenemos la URL, se pensó que habría que interactuar con la API de Snap!, sin embargo, tras ver el código fuente descubrimos que no es necesario ya que existe una función implementada en JavaScript que te devuelve el XML simplemente haciendo un GET con el recurso /projects/user\_name/project\_name a Snap! Berkeley. 

En la figura~\ref{figura:xml} se ven los pasos necesarios para conseguir los datos de un proyecto de Snap! Berkeley: el usuario envía la URL de su proyecto a través de un POST, se parsea la URL, se forma la nueva URL y se hace una petición GET con esa URL a Snap! Berkeley; el cual, nos devuelve el XML correspondiente.

  \begin{figure}[h]
            \centering
            \includegraphics[scale=0.55]{img/analizar.PNG}
            \caption{Petición del XML de un proyecto}
            \label{figura:xml}
    \end{figure}
        
  Una vez que tenemos el XML tenemos que parsearlo para poder obtener todos los datos necesarios y, para ello, hemos hecho uso de la API xml.sax. Un archivo XML es un texto compuesto de etiquetas creado para formar una estructura de datos e información. Gracias al \textit{ContentHandler} y al \textit{parser} de xml.sax podemos acceder a cada etiqueta y a su contenido. Para ello, la clase \textit{ContentHandler} define 3 funciones muy importantes:
 \begin{itemize}
     \item  \textit{def \_\_init\_\_ (self)} en la que se deben inicializar todas las variables.
     \item \textit{def startElement (self, name, attrs)} es la función que encuentra inicios de etiqueta XML, donde name se convierte en el nombre de la etiqueta y attrs en los atributos que hay en la etiqueta. Por ejemplo, block s=``move'' el nombre de la etiqueta es block, el atributo es s y su valor es move. En este punto guardaremos en un archivo JSON los atributos y valores correspondientes según necesitemos. Se ha tomado la decisión de trabajar con JSON porque es mucho más sencillo y rápido.
     \item \textit{def endElement(self, name)} es la función que se encuentra con el cierre de etiquetas XML y sirve para saber que ya has avanzado a otra etiqueta.

 \end{itemize}
 Para analizar un documento XML tenemos que:
 \begin{itemize}
     \item Crear un lector de XML con \textit{make\_parser()}.
     \item Crear un manejador de contenido del XML con \textit{myContentHandler()}.
     \item Definir las funciones del \textit{ContentHandler} y añadírselas al \textit{parser} con \textit{setContentHandler(theHandler)}.
     \item Parsear la url donde se encuentra el archivo XML con el parser ya definido.
 \end{itemize}
 
Este paso puede que haya sido el más complicado de todos pues los proyectos de Snap! tienen una estructura XML más o menos similar pero no llega a ser única por lo que al intentar analizar las etiquetas resultó difícil porque no todos los proyectos encajaban con lo que había definido. En la figura~\ref{figura:tree} se refleja el esquema de etiquetas que se ha supuesto y cómo lo hemos guardado. Con esta estructura pretendemos poder guardar en un JSON solamente los sprites que hay, los scripts y los bloques que se utilizan. Como extra se han guardado las variables y los bloques que puede crear un usuario. \\
El JSON se compone de 4 listas (sprites, variables, block-definition y name block-definition) que contienen diccionarios con sus datos. Por ejemplo, en sprites se guardan diccionarios por cada bloque parseado con los campos nº sprite, nº script, block y nº block.
\\
\begin{figure}[h]
\centering
            \includegraphics[scale=0.52]{img/tree_xml.PNG}
            \caption{Estructura seguida para parsear el XML y estructura seguida para guardar los datos parseados}
            \label{figura:tree}
    \end{figure}
    
Una vez que los datos se han guardado en el JSON, se procedió a implementar la rúbrica en Django con ocho categorías: paralelismo, abstracción, datos, flujo de control, diversidad o categorías, condicionales, sincronización e interactividad. Los criterios de evaluación quedan reflejados en la tabla~\ref{tabla:rubrica} y tiene de base la de Dr. Scratch~\cite{moreno2015dr}. Cada categoría tendrá, por tanto, una puntuación Nula (0), Básica (1), Intermedia (2) o Avanzada (3), y para la puntuación global, se hará la media de las ocho categorías resultando una puntuación de: nivel nulo de 0 a 0,5, básico de 0,5 a 1,5, intermedio de 1,5 a 2,5 y avanzado de 2,5 a 3. Si el usuario ha iniciado sesión toda esta información se guarda en la base de datos en la tabla \textit{proyecto} ya mencionada.

\begin{table}
\centering
\begin{tabular}{l|l|l|l|}
\cline{2-4}
 & Básico & Intermedio & Avanzado \\ \hline
\multicolumn{1}{|l|}{Paralelismo} & \begin{tabular}[c]{@{}l@{}}1 sprite \& \textgreater{}= 2 scripts\\ receiveGo\\ receiveKey\end{tabular} & \begin{tabular}[c]{@{}l@{}}\textgreater{}= 2 sprites \& \textgreater{}= 1 script\\ receiveGo\\ receiveKey\end{tabular} & \begin{tabular}[c]{@{}l@{}}\textgreater{}=1 sprite \& 2 \textgreater{}= scripts\\ receiveCondition\\ receiveMessage\\ receiveOnClone\end{tabular} \\ \hline
\multicolumn{1}{|l|}{Condicionales} & Do if & \begin{tabular}[c]{@{}l@{}}DoIfElse\\ ReportIfElse\end{tabular} & \begin{tabular}[c]{@{}l@{}}ReportAnd\\ ReportOr\\ ReportNot\end{tabular} \\ \hline
\multicolumn{1}{|l|}{Control flujo} & \textgreater{}= 2 blocks en un script & \begin{tabular}[c]{@{}l@{}}DoForever\\ doRepeat\end{tabular} & \begin{tabular}[c]{@{}l@{}}DoUntil\\ for\end{tabular} \\ \hline
\multicolumn{1}{|l|}{Abstracción} & \textgreater{}=2 scripts & \textgreater{}=2 scripts, sprites & Definition-blocks \\ \hline
\multicolumn{1}{|l|}{Sincronización} & doWait & \begin{tabular}[c]{@{}l@{}}doBroadcast\\ receiveMessage\\ doStopThis\\ doPauseAll\end{tabular} & \begin{tabular}[c]{@{}l@{}}doWaitUntil\\ doBroadcastAndWait\\ receiveOnClone\\ receiveCondition\end{tabular} \\ \hline
\multicolumn{1}{|l|}{Interactividad} & \begin{tabular}[c]{@{}l@{}}receiveGo\\ receiveKey\end{tabular} & \begin{tabular}[c]{@{}l@{}}receiveInteraction\\ reportTouchingObject\\ reportKeyPressed\end{tabular} & \begin{tabular}[c]{@{}l@{}}doAsk\\ video\\ audio\end{tabular} \\ \hline
\multicolumn{1}{|l|}{Datos} & Atributos de los personajes & Operaciones con variables & Operaciones con listas \\ \hline
\multicolumn{1}{|l|}{Diversidad} & \textless{}= 2 categorías & 2\textless{}categorías\textless{}=6 & \textgreater{}=7 categorías \\ \hline
\end{tabular}
\caption{Rúbrica implementada para analizar proyectos de Snap!}
\label{tabla:rubrica}
\end{table}

\subsection{Usuarios}
Se propuso la idea de que los usuarios tuviesen la opción de hacerse una cuenta y así poder guardar todos los proyectos analizados en la base de datos. Para ello, se implementó en primer lugar la opción de iniciar y cerrar sesión gracias a las funciones de \textit{login} y \textit{logout} que ofrece Django en su sistema de autenticación (\textit{django.contrib.auth.models}). Este sistema permite distinguir cuando un usuario está autenticado y cuando no, pudiendo hacer funciones exclusivamente para usuarios como es el caso del recurso \textit{/projects} que muestra los proyectos que el usuario ha analizado previamente. Sin embargo, para crear usuarios se tenía que gestionar desde el recurso /admin y solo lo podía hacer el superusuario, por lo que se añadió la opción de hacerse una cuenta. Se puede importar un formulario para crear un usuario que ya viene predefinido (pero de aspecto modificable) en \textit{django.contrib.auth.models} y a partir de él, un usuario se registra y solo faltaría que en la función de \textit{signup} autenticásemos ese usuario y lo iniciásemos sesión directamente. En la figura~\ref{figura:sign} se observa la página de iniciar sesión y la de hacerse una cuenta. Cabe destacar que se implementó que si el usuario estaba logueado apareciese un recuadro arriba de todas las páginas con la opción de cerrar sesión. Los usuarios con sus contraseñas quedan guardados en la tabla de la base de datos denominada \textit{auth\_user}.

\begin{figure}[h]
\centering
            \includegraphics[scale=0.5]{img/sign.PNG}
            \caption{Inicio de sesión y registro en Dr. Snap!}
            \label{figura:sign}
\end{figure}
    
\subsection{Modo profesor o estudiante}
Con la anterior opción se conseguía tener una base de datos con los proyectos analizados de los usuarios pero Dr. Snap! pretende ir más allá que analizar solo proyectos, como herramienta docente debe aportar distintas funcionalidades según el tipo de usuario que seas. Surge así, la distinción entre si eres estudiante o eres un profesor. Para ello se crea el modelo ``tipo'' que ya hemos mencionado donde se asocia el usuario con el tipo de usuario. Se implementa de forma que al darle al enlace de ``hacerse una cuenta'', mostrado en la figura~\ref{figura:sign}, te lleve al recurso /type-signup donde tienes dos formularios para elegir si eres estudiante o profesor. Una vez que seleccionas el tipo, la nueva entrada se guarda en la base de datos y se te redirige a la página de registro de la figura~\ref{figura:sign}. Esta funcionalidad queda reflejada en la figura~\ref{figura:tipo}. A continuación, se definen las prestaciones de casa modo:

\begin{itemize}
    \item Estudiante: tiene la opción de analizar sus proyectos y de ver gráficos con los proyectos analizados según los niveles obtenidos.
    \item Profesor: puede analizar proyectos propios o un conjunto de proyectos que deben estar comprimidos en formato ZIP. Se pensó que un profesor tendría varias clases y sería más sencillo analizar todos los proyectos de una clase subiéndolo como ZIP. Además, se da la opción de poder descargar en formato CSV la clase entera introduciendo el nombre del archivo ZIP que haya sido analizado previamente.
\end{itemize}

\begin{figure}[h]
\centering
            \includegraphics[scale=0.5]{img/tipo.PNG}
            \caption{Página para elegir el tipo de usuario en el proceso de registro en Dr. Snap!}
            \label{figura:tipo}
    \end{figure}
    
\subsection{Analizar ZIPs}
Para poder analizar un archivo ZIP debe ser subido primero a la aplicación por el usuario de tipo profesor. En la función de analizar proyectos, si estás logueado como profesor aparece un nuevo formulario en el que se ha implementado la posibilidad de importar un ZIP desde el ordenador. Para trabajar con el archivo comprimido hemos utilizado la biblioteca ``FileSystemStorage'' importada de ``django.core.files.storage'' y con la biblioteca ``zipFile''. De primeras, se dudó si trabajar con el archivo en local o en disco. Al final, me decanté por guardarlo en disco y trabajar con él ya que era menos complejo. En la figura~\ref{figura:zip} se muestran las opciones que ofrece la página analizar en caso de ser profesor. Los pasos para esta funcionalidad son los siguientes:
\begin{itemize}
    \item Guardar el archivo ZIP en la carpeta llamada media, vista en la figura~\ref{figura:carpetas}. Esto se consigue con una función de ``FileSystemStorage'' llamada~\textit{fs.save()}.
    \item Quedarnos con la url donde se encuentra el ZIP con la función~\textit{fs.url()}.
    \item Descomprimir el ZIP con ``zipFile'' en una carpeta que se hace llamar: \textit{nombredeusuario\&nombredelarchivo } con la función~\textit{fs.urlextractall (password, path)}.
    \item Analizar cada proyecto calculando las puntuaciones y guardando los datos en la base de datos. En este punto es cuando se decide añadir un campo del modelo \textit{proyecto} que se llamó \textit{nombre\_zip} ya que de esta forma los proyectos que no pertenecen a ningún ZIP simplemente este campo se pondría a NULL.
\end{itemize}
\begin{figure}[h]
\centering
            \includegraphics[scale=0.35]{img/zip.PNG}
            \caption{Formularios para subir un ZIP o analizar un proyecto en Dr. Snap!}
            \label{figura:zip}
    \end{figure}
\subsection{Dashboard}
       Los 3 dashboard que tenemos son los que enseñamos en la figura~\ref{figura:dshboard2} y otro más donde se comparan los resultados de dos ZIPs que se hayan subido a la aplicación (figura~\ref{figura:dshboard}). Los datos que hemos cogido son los resultados de los proyectos que hay guardados en las cuentas de un estudiante o un profesor, es decir, han debido ser analizados previamente y guardados en la base de datos. ~Según el modo:
    \begin{itemize}
        \item Estudiante: sólo están disponibles los gráficos de la figura ~\ref{figura:dshboard2} y en ella se muestran los resultados de los proyectos que el alumno ha analizado en Dr. Snap! en un diagrama de barras y en donut.\\
        \begin{figure}[h]
            \centering
            \includegraphics[scale=0.4]{img/dashboard.PNG}
            \caption{Dashboard de barra y de donut.}
            \label{figura:dshboard2}
        \end{figure}
        
        \item Profesor: además de los mencionados, se da la opción de ver los gráficos con los datos de una clase o incluso comparar un gráfico con dos clases diferentes (figura~\ref{figura:dshboard}). Cuando hablamos de clase se debe entender como un ZIP con los proyectos de los alumnos de una clase y que esta se ha analizado previamente gracias a la opción que damos de analizar ZIP.
        
         \begin{figure}[h]
            \centering
            \includegraphics[scale=0.4]{img/comparar.PNG}
            \caption{Comparación de dos Zips.}\label{figura:dshboard}
        \end{figure}
       
    \end{itemize}
    Para implementarlos hemos tenido que añadir un elemento ``canvas''~ de HTML que básicamente es un contenedor donde se dibujan los gráficos gracias a la biblioteca de JavaScript ya mencionada ``Chart.js''. Una vez que dichos gráficos estaban implementados, se ha añadido la funcionalidad de que si haces click en una de las barras, por ejemplo en la azul de basic, te redirija a una tabla donde aparecen todos los proyectos de nivel básico. Esto ha requerido el aprendizaje de la programación basada en eventos ya que hacer click en la pantalla es un evento llamado onClick y hay que manejarlo para que distinga si estás pinchando dentro del elemento \textit{canvas}, si es fuera de las barras o porciones del donut y en caso de que sea dentro de ellas, distinguir qué nivel está pinchando.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EXPERIMENTOS Y VALIDACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Experimentos y validación}


Para validar y testear la aplicación web hemos distinguido diferentes fases o puntos a lo largo que ha ido avanzando el proyecto. En orden cronológicos tenemos las siguientes validaciones:
\section{Parseo del XML}
Para ello se tuvieron que analizar más de 50 proyectos, algunos creados por mí y otros cogidos de proyectos subidos a Snap! Berkeley. Con esto se pretendía deducir la estructura más común y global que presentaban la mayoría de los proyectos en formato XML. Por ejemplo, en la figura~\ref{figura:xml-1} se muestra el fichero XML que se obtiene al añadir simplemente el bloque \textit{move} en un script. En primera instancia se supuso que los XML tendrían las etiquetas project, stage, sprites, sprite, scripts, script y block ya que en en stage están todos los sprites, en cada sprite están los scripts y en cada script están los bloques utilizados. Sin embargo, esta aproximación era errónea ya que al agregar nuevos bloques el XML añadía nuevas etiquetas que provocaban continuos errores de lectura. Algunos puntos a tener en cuenta son:
\begin{figure}[h]
            \centering
            \includegraphics[scale=0.6]{img/xml_val.PNG}
            \caption{Primera aproximación estructura XML}
            \label{figura:xml-1}
        \end{figure}
        

\begin{itemize}
    \item Se debe distinguir la etiqueta \textit{block} con dos atributos muy importantes: \textit{s} que hace referencia a todos los bloques ya definidos por Snap! Berkeley y \textit{custom} que hace referencia a los creados por los usuarios. 
    \item Se debe tener en cuenta que los bloques definidos pueden aparecer tanto a la altura de block (con el atributo \textit{custom}) como a la altura de los sprites (con la etiqueta \textit{block-definition}).
    \item Las variables se pueden tratar de igual manera que el punto anterior.
    \item Un bloque ya predefinido por Snap! tiene la etiqueta block y el atributo \textit{s}. Sin embargo, hay algunos bloques que pueden tener scripts dentro como observamos en la figura~\ref{figura:script-block}. Esto debe tenerse en cuenta a la hora de abrir o cerrar las etiquetas scripts ya que puede hacerse de forma errónea.
    \begin{figure}[h]
            \centering
            \includegraphics[scale=0.5]{img/block-script.PNG}
            \caption{Script dentro de un bloque}
            \label{figura:script-block}
        \end{figure}
\end{itemize}
La estructura final se mostró anteriormente en la figura~\ref{figura:tree} junto con el JSON donde se guardaron los datos de interés a la vez que se parseaba el XML. En la figura~\ref{figura:JSON} se muestra el archivo JSON que se guarda tras analizar el proyecto de la figura~\ref{figura:script-block} y podemos observar que en la lista sprites tenemos dos diccionarios: uno para el bloque ``repeat'' y otro para el bloque ``move''. Destacamos que ambos bloques pertenecen al sprite 1 y al script 1 como se indica en los valores de cada diccionario y como extra guardamos el número de cada bloque por saber el máximo de bloques que se usan en el proyecto. Al no tener variables ni bloques definidos, ambas listas están vacías.
 \begin{figure}[h]
            \centering
            \includegraphics[scale=0.55]{img/json.PNG}
            \caption{JSON que guarda los datos de un XML.}
            \label{figura:JSON}
        \end{figure}
 
 \section{Implementación rúbrica en Django}
 Para la implementación de la rúbrica se han definido 3 funciones auxiliares que dan información sobre los datos del JSON guardado y 8 funciones principales que calculan la puntuación de cada sección. Las 3 funciones auxiliares son: calcular el número total de scripts, calcular el número total de sprites y ver si hay más de dos bloques en un script. Para validar esto usaremos un ejemplo fácil pero con mayor contenido como el de la figura~\ref{figura:snap-ej} que consta de 1 sprite, 2 scripts y 7 bloques.
    \begin{figure}[h]
            \centering
            \includegraphics[scale=0.6]{img/ej_rubrica.PNG}
            \caption{Ejemplo de Snap!}
            \label{figura:snap-ej}
        \end{figure}
        
    Las puntuaciones que deberían aparecer basándonos en la tabla~\ref{tabla:rubrica} son:
    \begin{itemize}
        \item Paralelismo: 1 sprite, 2 scripts y uso de bandera verde supone estar en la puntuación básica (1).
        \item Condicionales: no se usa ningún bloque condicional ni operadores lógicos por lo que la puntuación es nula (0).
        \item Control de flujo: el primer script tiene 3 bloques y el segundo 2 lo que supone una puntuación básica. Sin embargo, el uso del bloque ``forever'' asciende la puntuación a intermedia (2).
        \item Abstracción: el tener 1 sprite, 2 scripts y ningún bloque definido supone una puntuación básica (1).
        \item Sincronización: en este ejemplo no hay ningún tipo de sincronización por lo que la puntuación debería resultar nula (0).
        \item Interactividad: la única interacción que observamos es la bandera verde por lo que tenemos una puntuación básica (1).
        \item Categorías o diversidad: tenemos en total 4 categorías diferentes por lo que la puntuación sería intermedia (2).
        \item Representación de datos: no se han definido ni variables ni listas pero usamos los atributos de posición ``move'' y ``turn'' por lo que la puntuación será básica (1).
    \end{itemize}
En la figura~\ref{figura:analisis-ej} confirmamos que las puntuaciones esperadas son las correctas y validamos por tanto la implementación de la rúbrica.
\begin{figure}[h]
            \centering
            \includegraphics[scale=0.37]{img/validacion-ej.PNG}
            \caption{Ejemplos análisis de un proyecto.}
            \label{figura:analisis-ej}
        \end{figure}
        
\section{Iniciar sesión y registrarse}

Como ya hemos mencionado, para registrarse es necesario elegir el tipo de usuario (profesor o estudiante) y rellenar un formulario con los campos: nombre de usuario y contraseña. Crearemos un usuario que sea de tipo profesor, se llame \textit{maria21} y su contraseña sea \textit{telecomunicaciones2021}. En la figura~\ref{figura:validacion-user} se puede observar como el usuario ha quedado bien registrado en la base de datos.
\begin{figure}[h]
            \centering
            \includegraphics[scale=0.37]{img/validacion-user.png}
            \caption{Base de datos con las tablas \textit{user} y \textit{tipo}.}
             \label{figura:validacion-user}
        \end{figure}

\section{Proyectos en la base de datos}

Al analizar un proyecto de un usuario registrado se deben guardar el usuario, las puntuaciones del proyecto y su nivel asociado, el nombre del proyecto, la URL de nuestra aplicación web, la URL de Snap! y si es zip o no. Desde el usuario de \textit{maria21} vamos a analizar el proyecto de la figura~\ref{figura:snap-ej} y podemos ver en la figura~\ref{figura:validacion-bbdd} que se han guardado todos los datos de forma correcta en la base de datos. Con esta tabla seremos capaces de acceder cuando queramos a las puntuaciones del proyecto gracias al recurso \textit{/project/\<name\_project>} que accede a esta base de datos filtrando por usuario y nombre del proyecto.
\begin{figure}[h]
            \centering
            \includegraphics[scale=0.37]{img/maria21.png}
            \caption{Proyecto guardado en la base de datos.}
             \label{figura:validacion-bbdd}
        \end{figure}
        
\section{ZIPs en la base de datos}
De igual forma que en la sección anterior, vamos a comprobar que al analizar un ZIP los datos quedan correctamente guardados en la base de datos. El ZIP denominado \textit{validacion.zip} usado de ejemplo  consta de 3 proyectos sacados de Snap! Berkeley llamados: \textit{Dogde.xml}, \textit{ S2E1 - Human body scanner.xml} y \textit{Sierpinski carpet.xml}. En la figura~\ref{figura:bbdd-zip} podemos ver como se han añadido los tres proyectos nuevos pertenecientes a \textit{validacion.zip} a la base de datos que teníamos en la figura~\ref{figura:validacion-bbdd}.
\begin{figure}[h]
            \centering
            \includegraphics[scale=0.37]{img/bbdd-zip.png}
            \caption{ZIP guardado en la base de datos.}
             \label{figura:bbdd-zip}
        \end{figure}
\section{ZIP exportado como CSV}
Usando el ZIP anterior si le damos a descargar como CSV en nuestra aplicación web observamos en la figura~\ref{figura:csv} que se exportan los datos de forma correcta. Simplemente se muestra el nombre del ZIP, el nombre del proyecto, el nivel del proyecto global y las puntuaciones de cada categoría. Esta funcionalidad se añadió como una ayuda a los profesores.
\begin{figure}[h]
            \centering
           \includegraphics[scale=0.5]{img/csv.png}
            \caption{CSV correspondiente al ejemplo \textit{validacion.zip}.}
             \label{figura:csv}
        \end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RESULTADOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Resultados}

Para ver los resultados de nuestra aplicación web haremos una distinción entre el modo profesor y el modo estudiante ya que cada uno tiene diferentes posibles respuestas.
\section{Modo estudiante}
Crearemos un usuario llamado \textit{pablo21} de tipo estudiante y vamos a analizar nuestro primer proyecto llamado \textit{Benham} sacado de la URL \url{https://cloud.snap.berkeley.edu/project?user=kinestheticlearning&project=Benham}. En la figura~\ref{figura:Benham} se muestra el resultado de analizar dicho proyecto.

\begin{figure}[h]
            \centering
           \includegraphics[scale=0.25]{img/ej-estudiante.png}
            \caption{Página resultante de analizar el proyecto \textit{Benham}.}
             \label{figura:Benham}
        \end{figure}

Ahora si analizamos varios proyectos más con el mismo usuario tenemos la opción de ver una tabla donde se muestran todos los proyectos analizados con sus respectivas puntuaciones gracias al recurso \textit{/projects}. Esto se refleja en la figura~\ref{figura:project-es} y cabe mencionar que la fila de \textit{proyecto} son enlaces que te llevan a los resultados individuales del análisis de cada uno.

\begin{figure}[h]
            \centering
           \includegraphics[scale=0.3]{img/projects-estudiante.png}
            \caption{Página que muestra todos los proyectos analizados por el usuario.}
             \label{figura:project-es}
        \end{figure}
        
Otra funcionalidad es que el estudiante tiene la opción de ver dos dashboard con los proyectos analizados como en la figura~\ref{figura:dash-es}. En ellos se puede ver que hay 3 proyectos de nivel intermedio y uno de nivel avanzado.
\begin{figure}[h]
            \centering
           \includegraphics[scale=0.3]{img/dashboard-es.png}
            \caption{Página que muestra los dashboard de los proyectos.}
             \label{figura:dash-es}
        \end{figure}
        
Por último, si hacemos \textit{click} en la barra amarilla de valor intermedia, s nos va a redirigir a una página que implementa la tabla de proyectos vista en la figura~\ref{figura:project-es} pero solamente mostrando los proyectos de nivel intermedio. Esta funcionalidad es útil para cuando un estudiante quiera ver solamente los proyectos de un único nivel.
\begin{figure}[h]
            \centering
           \includegraphics[scale=0.3]{img/intermediate-es.png}
            \caption{Página que muestra los proyectos del nivel cuando haces \textit{click} en el dashboard.}
             \label{figura:click-es}
        \end{figure}
        
\section{Modo profesor}
Aparte de tener las mismas funcionalidades que se ofrecen en el modo estudiante veremos los resultados de analizar un ZIP denominado \textit{modo-profesor.zip} que guarda los mismos proyectos que ha analizado el estudiante \textit{pablo21} para así ver que los resultados son los mismos. En la figura~\ref{figura:zip-pr} observamos los resultados de analizar el ZIP y vemos que son los mismos que cuando los proyectos se analizaron por separado. 

\begin{figure}[h]
            \centering
           \includegraphics[scale=0.35]{img/resultado-zip.png}
            \caption{Página que muestra los proyectos analizados de un ZIP.}
             \label{figura:zip-pr}
        \end{figure}

Por último, podemos ver los dashboard de los proyectos analizados como los estudiantes pero si queremos ver el de algunos de los ZIPs analizados o comparar dos de ellos tendremos que rellenar los formularios de la figura~\ref{figura:form-pr}.

\begin{figure}[h]
            \centering
           \includegraphics[scale=0.4]{img/form-zip.png}
            \caption{Formularios para obtener los dashboard correspondientes.}
             \label{figura:form-pr}
        \end{figure}
        
El resultado de obtener el dashboard de \textit{modo-profesor.zip} resulta el mismo que en la figura~\ref{figura:dash-es} y el resultado de comparar el archivo \textit{modo-profesor.zip} y el archivo \textit{validaciones.zip} (previamente utilizado) se observa en la figura~\ref{figura:zips-pr}

\begin{figure}[h]
            \centering
           \includegraphics[scale=0.35]{img/comparar-ej.png}
            \caption{Comparación de dos ZIPs}
             \label{figura:zips-pr}
        \end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSIONES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Conclusiones}
\label{chap:conclusiones}


\section{Consecución de objetivos}
\label{sec:consecucion-objetivos}
La aplicación web ha conseguido los objetivos planteados ya que permite ser una herramienta docente tanto para un alumno como para un profesor. Ofrece diversas funcionalidades que pueden llegar a ser muy útiles para el ámbito académico y para la mejora y desarrollo de los conocimientos de programación. Cabe destacar que funciona solamente si las URLs de los proyectos pertenecen al dominio de \url{https://cloud.snap.berkeley.edu/} y no a \url{https://snap.berkeley.edu/} por lo que puede llevar a que te salga un error en la aplicación web. Otro error a mencionar que puede producirse es que el proyecto no cumpla con la estructura de parseo XML que hemos definido y ello haría imposible el análisis de dicho proyecto pero es un caso muy poco común. Por lo demás, la aplicación cumple lo cometido y predefinido en los objetivos.
\section{Aplicación de lo aprendido}
\label{sec:aplicacion}

A lo largo de mi carrera he aprendido muchos conocimientos gracias a diversas asignaturas y ello ha hecho posible este trabajo de fin de grado. Estas son:

\begin{enumerate}
\item Fundamentos de la Programación me permitió aprender a comprender la programación y comenzar a pensar como un ``buen'' programador.
\item Programación de Sistemas de Telecomunicación me enseñó la implementación del modelo cliente-servidor.
 \item Servicios y Aplicaciones Telemáticas me ha enseñado el uso de Django y el diseño del \textit{FRONTEND} en aplicaciones webs.
  \item Desarrollo de aplicaciones telemáticas, aunque nunca llegué a cursarla, con los apuntes de mis compañeros he aprendido el uso de CSS y la mejora en apariencia del diseño web. 
  \item Ingeniería de Sistemas de Información me ha permitido aplicar los conocimientos de bases de datos que imparte la asignatura.
\end{enumerate}

\section{Lecciones aprendidas}
\label{sec:lecciones_aprendidas}
La realización de este proyecto ha hecho que aumenten mis conocimientos en distintas áreas de telecomunicaciones:

\begin{enumerate}
  \item Apariencia de páginas webs con CSS y las templates de HTML. He aprendido sobre todo a diseñar botones, menús o formularios.
  \item Mejora en el lenguaje Python y el entorno Django. He desarrollado conocimientos en el manejo de estructuras XML, de diccionarios y listas, de archivos JSON y en la abstracción de procedimientos o funciones demasiado grandes para dividirlas en apartados más pequeños. Además, he ampliado mis conocimientos en los métodos de GET y POST para poder hacer peticiones.
  \item Probablemente lo que más haya aprendido haya sido el uso de JavaScript puesto que era la primera vez que lo usaba y me ha enseñado sobre todo la programación basada en eventos.
  \item Pythonanywhere es un servidor gratuito que no sabía que existía y que es muy útil porque admite proyectos de Django ya implementados y es sencillo de utilizar.
\end{enumerate}


\section{Trabajos futuros}
\label{sec:trabajos_futuros}

Un posible proyecto futuro sería la mejora de esta herramienta para que admita todo tipo de proyectos de Snap! independientemente de su estructura XML y que aporte nuevas funcionalidades como alguna de \textit{machine learning} que pueda ver patrones de error repetidos y ayude a los estudiantes a mejorar en su programación evitando dichos patrones.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APÉNDICE(S) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\chapter{Manual de usuario}
\label{app:manual}

Esto es un apéndice.
Si has creado una aplicación, siempre viene bien tener un manual de usuario.
Pues ponlo aquí.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{abbrv}
\bibliography{memoria}  % memoria.bib es el nombre del fichero que contiene
% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información: 
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/

\end{document}
